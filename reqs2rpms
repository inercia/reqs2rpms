#!/usr/bin/env python2.7

import glob
import os
import argparse
import shutil
import shlex
import logging
from subprocess import Popen
import tempfile
from time import sleep
import sys
import platform

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

_VERSION = '1.0'
_DESCRIPTION = """
Utility for generating RPMs from a requirements.txt or a setup.py file

Example:

$ ./reqs2rpms --keep-dir -r reqs.txt -o out_dir

"""

#: default cache directory for downloads
_DEFAULT_DOWN_CACHE = '/tmp/reqs2rpms'

#: pattern for produced RPMs
_RPMS_PATTERNS = ['*.noarch.rpm',
                  '*.%s.rpm' % platform.machine()]

#: list of requirements we do not really want to download/install... (in lower case)
_SKIP_REQS = {'setuptools', 'distribute'}

#: the arguments for setup.py
_BDIST_RPM_COMMAND = 'bdist_rpm --binary-only -q'

#: pip download command
_PIP_DOWNLOAD_COMMAND = 'pip install -M %s --download-cache %s --download %s --no-install %s'

#: pip download command
_PIP_EDITABLE_COMMAND = 'pip install -M %s --download-cache %s --download %s --no-install -e %s'

#: file patterns and how to uncompress them
_UNCOMPRESS_PATTERN_COMMAND = {
    '*.tar.gz': 'tar xvpf {filename}',
    '*.zip': 'unzip -xU {filename}',
}


def _count_subdirs(directory):
    """ Count the number of subdirectories in a directory
    """
    return len([d for d in glob.glob(directory + '/*') if os.path.isdir(d)])

def _count_files(directory):
    """ Count the number of files in a directory
    """
    return len([f for f in glob.glob(directory + '/*') if os.path.isfile(f)])


def run_executable(args, wait=True, **kwargs):
    """ Run an executable
    :param args: a list of arguments to use when running the executable (optional)
    """
    close_fds = kwargs.pop('close_fds', True)
    cwd = kwargs.pop('cwd', None)

    proc = Popen(args, cwd=cwd, close_fds=close_fds, **kwargs)
    if wait:
        retcode = None
        while True:
            proc.poll()
            if proc.returncode is not None:
                retcode = proc.returncode
                break
            sleep(1)

        return retcode, proc
    else:
        return None, proc


def uncompress_all(directory):
    """ Uncompressed all files in a directory
    """
    for pattern, command in _UNCOMPRESS_PATTERN_COMMAND.iteritems():
        logger.info('Uncompressing everything at %s', directory)
        for f in glob.glob(directory + '/' + pattern):
            if os.path.isfile(f):
                args = shlex.split(command.format(filename=f))
                logger.debug('... uncompressing %s', f)
                retcode, proc = run_executable(args=args, cwd=directory)
                if retcode != 0:
                    raise RuntimeError('%s returned code %d' % (args[0], retcode))
                else:
                    logger.debug('...... done! removing "%s"', f)
                    os.remove(f)


def build_rpm(directory, setup_py, python, ignore_build_errors=False):
    """ Build an RPM from a directory with a setup.py
    :param directory:
    :return:
    """
    logger.info('Building RPM from "%s"', setup_py)
    args = [python, setup_py] + shlex.split(_BDIST_RPM_COMMAND) + ['--python', python]
    retcode, proc = run_executable(args, cwd=directory, close_fds=False)
    if retcode != 0 and not ignore_build_errors:
        raise RuntimeError('setup.py returned code %d when running %s' % (retcode, setup_py))


def collect_rpms(directory, out):
    """ Collect all the RPMs we built
    :param directory: directory where we look for RPMs
    """
    n = 0
    logger.info('Collecting RPMs at %s', directory)
    dist_dir = os.path.join(directory, 'dist')
    for pattern in _RPMS_PATTERNS:
        for f in glob.glob(dist_dir + '/' + pattern):
            if os.path.isfile(f):
                logger.debug('... found "%s" -> copying to "%s/"', directory, out)
                shutil.copy(f, out)
                n += 1
    logger.info('%d RPMs generated from %s', n, directory)
    return n


def post_process(output, download_dir, python, remove_setup_cfg=False, ignore_build_errors=False):
    """ Uncompress and install things
    :param ignore_build_errors: ignore errors when building, trying to build as many packages as we can
    """
    # uncompress things
    uncompress_all(download_dir)

    try:
        # look for setup.py's and run bdist_rpm on them...
        for setup_py in glob.glob(download_dir + '/*/setup.py'):
            dirname = os.path.dirname(setup_py)
            basename = os.path.basename(dirname)
            basename_split = basename.rsplit('-', 1)
            if basename_split[0].lower() in _SKIP_REQS:
                logger.info('Skipping %s...', basename_split[0])
                continue
            else:
                if remove_setup_cfg:
                    setup_cfg = os.path.join(dirname, 'setup.cfg')
                    if os.path.exists(setup_cfg):
                        logger.debug('removing %s', setup_cfg)
                        os.remove(setup_cfg)

                logger.info('*************** Processing %s ***************', basename_split[0])
                build_rpm(dirname, setup_py, python=python, ignore_build_errors=ignore_build_errors)
                collect_rpms(dirname, output)
    finally:
        logger.info('post processing finished: %d packages downloaded, %d RPMs generated',
                    _count_subdirs(download_dir), _count_files(output))

def download_from_reqs(reqs_file, download_dir, download_cache):
    """ Download everything from a requirements file
    """
    logger.info('Processing requirements file')
    logger.debug('Working on temporal directory "%s"', download_dir)

    n = 0
    reqs = [req.strip() for req in reqs_file.readlines()]

    # first of all, download all eggs
    for req_desc in reqs:
        if req.startswith("#"):
            continue
        elif len(req) == 0:
            continue
        else:
            logger.info('Downloading requirement: %s', req_desc)
            extra = ''
            pip_command = _PIP_DOWNLOAD_COMMAND % (extra, download_cache, download_dir, req_desc)
            args = shlex.split(pip_command)
            retcode, proc = run_executable(args=args)
            if retcode != 0:
                raise RuntimeError('pip returned code %d' % retcode)
            else:
                n += 1
    return n


def download_from_setup(setup_file, download_dir, download_cache):
    """ Download everything from a setup.py file
    """
    n = 0

    if os.path.isfile(setup_file):
        dirname = os.path.abspath(os.path.dirname(setup_file))
    else:
        dirname = os.path.abspath(setup_file)

    logger.info('Processing setup.py file from %s', dirname)
    extra = ''
    pip_command = _PIP_EDITABLE_COMMAND % (extra, download_cache, download_dir, dirname)
    args = shlex.split(pip_command)

    retcode, proc = run_executable(args=args)
    if retcode != 0:
        raise RuntimeError('pip returned code %d' % retcode)

    n = len(glob.glob(download_dir + '/*'))

def main():
    parser = argparse.ArgumentParser(description=_DESCRIPTION,
                                     formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-r',
                        '--reqs',
                        dest='reqs_file',
                        metavar='REQUIREMENTS',
                        help='requirements file',
                        type=argparse.FileType('r'),
                        default=None)
    parser.add_argument('-s',
                        '--setup',
                        dest='setup_file',
                        metavar='SETUP_PY',
                        help='setup.py file',
                        type=str,
                        default=None)
    parser.add_argument('-o',
                        '--output',
                        dest='output',
                        metavar='DIRECTORY',
                        required=True,
                        help='output directory where RPMs are stored (will be created if it does not exist)',
                        type=str,
                        default=None)
    parser.add_argument('--version',
                        action='store_true',
                        default=False,
                        help='displays the version and exits.')
    parser.add_argument('-c',
                        '--cache',
                        dest='download_cache',
                        metavar='DIRECTORY',
                        help='directory where downloads are cached',
                        type=str,
                        default=_DEFAULT_DOWN_CACHE)

    package = parser.add_argument_group('packaging options')
    package.add_argument('--group',
                         dest='group',
                         metavar='GROUP',
                         help='package group name',
                         type=str,
                         default=None)
    package.add_argument('--release',
                         dest='release',
                         metavar='RELEASE',
                         help='package release',
                         type=str,
                         default=None)

    advanced = parser.add_argument_group('advanced options')
    advanced.add_argument('--pip',
                          dest='pip',
                          metavar='EXECUTABLE',
                          help='pip executable to use',
                          type=str,
                          default=None)
    advanced.add_argument('--python',
                          dest='python',
                          metavar='EXECUTABLE',
                          help='python executable to use (default: %s)' % sys.executable,
                          type=str,
                          default=sys.executable)
    advanced.add_argument('--keep-dir',
                          dest='keep_dir',
                          action='store_true',
                          help='keep build dirs after packaging',
                          default=False)
    advanced.add_argument('--ignore-build-errors',
                          dest='ignore_build_errors',
                          action='store_true',
                          help='ignore errors when building, trying to build other packages',
                          default=False)
    advanced.add_argument('--keep-setup-cfg',
                          dest='remove_setup_cfg',
                          action='store_false',
                          help='keep the setup.cfg file found in packages (can break some RPM builds)',
                          default=True)

    args = parser.parse_args()

    if args.version:
        parser.exit(0, message='\nVersion: %s\n' % str(_VERSION))

    if not (args.reqs_file or args.setup_file):
        parser.exit(1, message='\nShould provide either a requirements.txt or a setup.py file\n')

    if not os.path.exists(args.output):
        logger.info('Creating output directory "%s"', args.output)
        os.makedirs(args.output)

    download_dir = tempfile.mkdtemp(prefix='reqs2rpm-')
    try:
        if args.reqs_file:
            download_from_reqs(args.reqs_file, download_dir=download_dir,
                               download_cache=args.download_cache)
        else:
            download_from_setup(args.setup_file, download_dir=download_dir,
                                download_cache=args.download_cache)

        post_process(output=args.output, download_dir=download_dir, python=args.python,
                     remove_setup_cfg=args.remove_setup_cfg, ignore_build_errors=args.ignore_build_errors)
    finally:
        if not args.keep_dir:
            logger.debug('Removing temporal directory "%s"', download_dir)
            shutil.rmtree(download_dir)


if __name__ == '__main__':
    main()
